\chapter{Introduction}
\label{sec:Introduction}
Creating network applications nowadays might be a complicated process of design which involves long series of research and experiments or, on the other hand, it might be a fairly simple procedure that takes only a tenth of its time and effort. In both cases, the most frequent evaluation metric is the scalability of the application, more than a thousand of lines of code or the complexity of the model. With the rise in popularity, the usage of network applications increases, which in consequence results in an increase in the frequency that the application is requested to serve its functionality. This growth can be calculated and included at the planning level, thus becoming a good programming practice that places itself close to other widely approved design patterns. With no doubt is scalability starting to play a more important role, being often set at the same level with such issues like portability or security[quote]. The present thesis aims to introduce an application that by its original functionality would heave the potential to become a heavy traffic network application with numerous active users.
Sections summary - what will be described! In chronological order.

\section{Popular notes taking applications}\label{sec:popular_apps} 
No matter if the user works on a small task like plan a holiday or whether they prepare a list of ideas which they aim to share secretly with their coworkers, a computer application will be a useful help.     
Currently, users have a rich variety of notes taking applications to choose from. One group of applications represents the idea of simple user interface which mimics the well known sticky notes or cork board where the notes are not long and relatively easy to find. Flagship representatives of this group are the Sticky Notes\footnote{This notes taking application used to be the default for notes taking under GNOME, one of the highly popular Linux desktop environments.}, Knotes\footnote{This application is a component of another application called Kontact, which is frequently used with KDE Linux desktop environment.} or the Stickies\footnote{A small and handy application which comes with Apple's Mac OS X that has rivals, e.g. SketchBox aiming at the possibilities of customization.}.The above applications offer simple text highlighting, syntax correction and general layout customization. On the other hand, the remaining group of applications has more features to offer, like rich text formatting with broad fonts support and a possibility of embedding multimedia elements and hyperlinks. Moreover, a number of the applications make use of Internet accounts where notes might be edited and tagged. Because of the great diversity among the applications, it seems worth presenting two of them which appear to deserve special attention and the below sections will briefly introduce and compare both.

\subsection{Google Notebook}\label{subsec:google_notebook}
The first application that appears remarkable is Google Notebook, a Google company product\footnote{Google offer a variety of products. Right next to the browser and the Gmail e-mail service, applications like Google Calendar, Google Docs, Picassa Web or YouTube reach more and more users.} open to the end user without charge or special restrictions. It makes use of typical Google design patterns, which makes its usage naturally easy for users familiar with other Google applications. What is more, Google Notebook has a number standard elements like bookmarks and tags, which shorten the search time when notes are kept in groups. Apart from that, the interface has extended WYSIWYG\footnote{WYSIWYG is an acronym for What You See Is What You Get and is used when referring to editors having user friendly interface, operating on a markup language (i.e.. HTML or \TeX) but at the same time allowing the user for manipulation of the output without having sound command of the markup language.} functionality, which makes the rich text formatting user friendly.

For various reasons, users might like to export their notebooks. With Google Notebook this task is said to be easy and the user has three possibilities to do it: export to HTML format, print or export to Google Doc format. What might be considered as even more practical is the opportunity to collaborate on a notebook with other people by marking the notebook as shared and then inviting others to contribute to it by passing a list of emails. This functionality allows for outstanding user experience where the users may share their ideas by working on one notebook simultaneously or separately. Nevertheless, Google was required to implement a simple Version Control System (henceforth VCS) within the feature in order to merge the parts into one piece and thus handle potential conflict situations. To give an example, a conflict might occur when two ore more users are editing the same content, i.e. the same sentence, but in different ways which makes further merging impossible. The way the situation is handled by Google is presented on the below picture \dots. As a result, the user then decides which version is the correct one. The above is only one of the two possibilities that VCS offers in that case. The second one is based on prioritizing performed by the user, where the modification time is registered and the conflict situation is overwritten with the version of the highest priority. All in all, that might appear as an interesting solution, but it also seems that it may lead to mistreating others users' work without an opportunity to notice and react to the conflict.

Finally, what may seam of insignificance importance, but is of huge significance in the light of the dynamic market growth of Internet applications, Google Notebook may be relatively confident of its position. As a matter of fact, already in May 2006 had Google released the initial version of Google Web Toolkit (henceforth GWT), which allowed for huge gains of Java script and CSS compression caring for cross browser compatibility. As a consequence, nowadays GWT is a powerful tool that provides the designer with the opportunity to make the Web based interface that works as required on a majority of browsers (including mobile devices) available on the market. That may seam even more significant, as the idea of having one's own notebook on mobile devices has a great potential. 

\subsection{Evernote}\label{subsec:evernote}
The second notes taking application that is worth describing is Evernote, which is a commercial product belonging to Evernote Corporation. It has a functional interface, a bunch of unique features and a still growing group of users. Moreover, the application supports multiple mobile devices, like various operating systems, and allows for adding, modifying and grouping notes taken by its users in a swift manner. Further advantages of the application regard the approach to how the notes are made in Evernote. Specifically, the product provides the opportunity to embed various multimedia elements in the notes, which converts the note taking into a process similar to editing a blog entry. Additionally, Evernote allows for clipping all items found on the Internet, from books, through cooking recipes, to interesting articles that the user wills to return to later. To take the argument further, the latter is possible when they use Evernote on the same or another device which has the product installed. It is worth mentioning the fact that this particular feature is especially useful to users dealing with a massive amount of information that cannot be read or memorized straight away and which, thanks to Evernote, may be stored in an easily searchable way. Yet another distinguished feature of Evernote is that images added to the product are also searchable, which means that text inscribed in the pictures is recognized as any other text, a point in case being a business contact card added to Evernote in couple of seconds by taking its photo, which may be afterwards found by typing in keywords from the card. By taking a photo of a ticket, bill or any other element with text element, Evernote users find it easy to use the elastic tool for importing data to their notes that otherwise would become lost or that would need significantly more time to arrive onto the product in the traditional way.

As mentioned in the beginning of this section, Evernote is a commercial product, which means that its code is proprietary software of Evernote Corporation. It may be used without charge with certain limitations, i.e. no collaboration option, limited file synchronization formats and lower monthly rate of multimedia elements that may be clipped to the application. Not surprisingly, free users are also required to accept typical promotion and advertisement materials in order to use the application. On the other hand, the cost of a premium account with extended options and lower limitations is 5\$ a month or 45\$ for a year, which still remains a reasonable price for such an interesting tool.      
 
\subsection{Comparison}
The above mentioned programs represent features with outstanding potential, yet defiantly, they fail to exploit all the features found in applications available on the market. Here, dynamics is an important factor which tends to follow the way users make use of the Internet daily, which should be considered especially when designing any kind of network application targeting an audience of considerable size. Fulfilling the requirements of keeping the speed of market changes and evolving with its users, the applications do not have their market success guaranteed, however, disrespecting the rules might generate a higher cost for the application -- losing all its users. Another rule that seems to be of significant importance is first user experience, which most commonly is built on the perception of the interface. Since currently users enjoy a wide choice of products, it is either the unique features of the application or the interface which trigger interest when users pick a product, which is easily translatable into the decision which application the user decides to use for longer and which they will never open again. Consequently, due to the fact that users naturally tend to have different habits and expectations, a rule of keeping the product as simple as possible supersedes applications with numerous advanced features and a complicated interface and it is this rule that emerges from all rankings of top rated notes taking products. 
If interface is so important, add a comment re the interface of Google Notebook versus Evernote - which one is regarded as a better one? Why? Also, is there any other feature that would distinguish between the two? Anything that would make one more advantageous than the other? Also, in one or two sentences list a few features that you find especially important for your application (you have to make connections with the real product you want to present).

Now build a link to VCS. How can we move from the notes taking applications to VCS? 
 
\section{Popular Version Control Systems}\label{sec:popular_vcs}
In order to describe VCS, the following scenario has been taken into consideraton. A group of developers are working together on a piece of software. Most probably, they divide the work into functional pieces and complete the necessary planning. Afterwards, they begin to code according to their company's coding standards, the approved methodology or favorite schema. Doubtlessly, the developers are required to interact not only by exchanging ideas but also by working on the same parts of code simultaneously and it is at that point when they prefer to be uninterrupted while working on their code, by the same time allowing other developers to track their progress or to make modifications they might find necessary to complete. That basic need was the primary reason for inventing an external software which additionally could inform the developer what changes have been implemented since the last time they worked on the code, a software that merges the work of several developers. 

Although currently there exists a wide variety of VCSs offering diverse functionality, the true golden age for VCS has started relatively recently. It was in 2001 when after the remarkable success of Concurrent Version Control (henceforth CVC) Jim Blandy and Karl Fogel released a project aiming to replace CVC by fixing the renown inconveniences of the system, introducing a more appealing architecture and a cleaner code~\cite[page 11]{hg_book}. The project was called Subversion, also known as SVN by its command line utility name, and despite the fact that it is CVC that probably holds a title of the world's most widely used VCS, it is SVN whose birth resulted in dozens of new and original concepts. Some of the concepts emerged soon after SVN was released and that regards Mercurial, Bazzar and Darts; others, like Git or Guilt, required time to evolve and attract new developers. Nevertheless, the first VCSs are much older and one of the very first ones, Source Code Control System, was grounded in 1970s at Bell Labs. Taking into account the fact that at that time computer popularity was not that significant, the dynamics in which the VCS systems were developed during those days would seem remarkable. The following section will describe one of the most outstanding VCSs which will serve as a base for the application presented in the practical chapters of the thesis.

\subsection{Mercurial}\label{subsec:hg}
Mercurial is a Distributed Version Control System (henceforth DVCS) and features of the latter will facilitate the understanding of how the Mercurial system might be used and which use cases it suits well. In comparison to SVN or any other centralized VCS, where only the main machine contains the repository with its history, DVCS provides every user with access to history on their hard disk, which in consequence enables the user to exploit the repository with all the available tools. Moreover, work remains undisturbed disregarding the server status as it is the user who plays the role of a server for themselves. This simple modification to the concept of centralized VCS was exactly what dynamically expanding Open Source projects were seeking. Each developer might work on their repository allowing others to use their work by performing merge operations, at the same time using work of other developers in the very same way. With DVCS, network connection to the main server was no longer needed in order to enjoy a functional environment where developers could create, analyze and modify the code whenever they preferred to. The latter was not only a step forward in making VCS more user friendly, but also improved the performance of this system. The very improvement was made with the completion of a number of actions. Firstly, all repository metadata was placed on users' hard discs as there was no reason to connect to the main server in order to find, for instance, the date when modifications of a class unexpectedly stopped working correctly. Secondly, the system was made fully scalable as in the case of DVCS, central machine, if present, is only used as a public main stream version of a project consuming minimum of the machine CPU and disc space, its only role being to allow users to download the most recent version of the repository. Thirdly, by having the project with its history saved on every developer's hard disc, the problem of backups was automatically solved and ensured total crash security. All the above advantages taken into account, it must also be made clear that  maintaining the repository with its history results in a significantly larger cumulative size of it. Indeed, metadata combined with development history forms a naturally additional overhead being stored on users' discs, even if typically it does not exceeds a tripled size of a free repository. Costly as it may seem, the latter is the price DVCS users agree to pay for additional functionality which the  system offers. It is also worth to note that the system's design has been what encourages its users to experiment. Certain operations, e.g. branching or forking, were created solely for that purpose. Moreover, it is worth to mention that making frequent tries beyond the main version was a desirable feature that was added to the system not only to maintain the cleanliness of the history, but also to allow developers perform as many tries as they are willing to, thus letting the system play a remarkable role in Open Source communities by helping to build and keep the community healthy~\cite{git_talk,svn_talk}. Finally, to bring the last, but not least advantage of Mercurial, it cannot escape attention that the DVCS has a number of additional commercial features. Bryan O'Sullivan points in~\cite[page 6]{hg_book} the following: 
\begin{itemize}
\item{Better availability and reliability for teams scattered across the globe.}
\item{Better scalability and ease of maintainance.}
\item{Greater flexibility, which might be a value for target customer.}
\end{itemize}
What is more, Mercurial is claimed to be quicker to learn and uses similar commands to the ones used in SVN or CSV, which eases the transition regardless of the operating system (the latter will be especially useful in terms of the Microsoft, Linux and Apple compatibility used in the tool presented in the following chapters). To hit the final note, Marcurial has an efficient HTTP protocol support~\cite{google_hg_git_compare} both as a client and server application, which serves as a useful feature when the work on particular repository tends to be very active within one developer group.

\subsection{Mercurial comparison with other systems}\label{subsec:dvcs_compare}
As a matter of fact, there exist a number of other DVCSs offering interesting functionality. Atomic commits, GUI\footnote{Graphical User Interface -- it eases the usage of system to users which are not used to work with command line tools.} tools, commits tagging, tracking merge operations in the history or allowing for user defined actions just before or after certain actions performed on repository are only few of the commonly used features in DVCS comparisons~\cite{wiki_dvcs_compare}. With time, the already long list~\cite{wiki_dvcs_list} will probably continue to expand; nevertheless, currently the most popular alternatives for Mercurial are Git and Bazzar, the former stemming from the Linux kernel developers community and the latter being associated in close vicinity to GNU\footnote{The name “GNU” is a recursive acronym for “GNU's Not Unix!”. The GNU Project was launched in 1984 to develop a complete Unix-like operating system with free software and at the time being, it is recognizable for the GNU/Linux operating system.} developers group. The similarities between the two systems are that both are remarkable, though using slightly different concepts, and both are based on the C language, which should positively impact their performance. However, it must be stated that the language requires compilation and in consequence it might not be suitable to systems which forbid running binary programs. Another significant difference regards the level of complexity. On the one hand, Git provides numerous commands and arguments allowing for full control over the repository and its history, while on the other hand Bazzar's flagship feature is the minimum time the user must spend on learning the proper usage of the VCS, which, at the same time, makes the system similar to Mercurial. The final difference regards the repository maintenance, in which Mercurial is claimed to be most efficient, not requiring additional operations like running \texttt{git-gc}\footnote{In order to achieve a better performance of disc space utilization, users of Git are advised to run the command on a regular basis, which is often compared to housekeeping by removing unnecessary objects or performing repository objects repack and compression. Interestingly, the name \texttt{git-gc} refers to a garbage collector, or a mechanism used in various programming languages for memory control.} in the case of Git or using less disc space than Bazzar finds necessary for the same repository. Apparently, all three systems have reached the level of maturity, which may be concluded taking into consideration the criteria of advanced commands usage and the availability of user interface tools. However, the most important reason why developer distinguish between existing VCSs is associated with the frequently offered functionality of a particular system and the habits the user used to have. Viewing this argument from a practical perspective, it must be noted that the criteria did not serve their purpose in the case of the application proposed in this thesis. The reason why Mercurial has been chosen is that the application required a lightweight yet powerful Python-based system with good support for running over HTTP requests. Further chapters will present the features in more detail, for now suffice it to mention that the support of Mercurial would not have been equally effective if it had not been compliant with the requirements of Python, which will be explored below.

\section{Role of programming language}\label{sec:languages}
Currently there exist dozens of programming languages among which some were invented years ago and still continue to evolve and the other, represented by newer ones that join most recognized elements of their predecessors and introduce new directions for development. Disregarding the languages' history and unique characteristics, each of them may be considered as a different tool in a programmer's toolbox. Following the remark made by Cal Henderson, "scalability isn't about using any particular technology at all"~\cite[page 203]{build_scalable}; it is the engineer, his experience and his ideas which count most and the rest is merely the workshop. Admittedly, it is of utmost importance to select the right tool for right task, yet usually the most powerful gear available is not a prerequisite. Quite the opposite, some languages may perfectly play their role due to their available components used in similar projects; alternatively, they may provide the shortest way to solve the particular problem. The decision on the language is made once, as rewriting entire projects from one language to another occurs relatively seldom as the process involves redesigning certain elements, which most surely consumes a lot of effort and time. On the other hand, reaching the right decision may bring ready-made solutions for most problems arising while a project is being developed. Finally, while it is likely the user will reach developers ready to help with problems they know from experience and happy to share their knowledge, identifying the right technology, hence the most useful language, is one of the very valuable skills that come with experience build on the method of trail and error. 
The following section will introduce Python, a language that is fundamental for the subject of the thesis, with an attempt to present its role not only in the tool itself, but also in the current language environment.
  
\subsection{Python}\label{subsec:py}
Python is a general-purpose programming language~\cite[page 3]{py_nutshell} and the variety of fields in which it has proved to be useful may impress. A shortened list of purposes the language served, according to Matt Telles~\cite[page 13]{py_power} includes:
\begin{itemize}
\item{Cinematography}
\item{Business information}
\item{Aviation}
\item{Government}
\item{Chemistry}
\item{Weather}
\item{GIS}
\item{Engineering}
\end{itemize}
The list may also be completed with universities, where Python is frequently used, with numerous lecturers following the reasoning of prof. James A. Hendler: "I have the students learn Python in our undergraduate and graduate Semantic Web courses. Why? Because basically there's nothing else with the flexibility and as many web libraries"~\cite{py_quote}. The reason why the language has gained such popularity through years may be best explained by its history.

Having been developed in the 1990's by a Dutch programmer Guido van Rossum, Python grew in popularity in an exceptionally dynamic manner since 2000~\cite{py_code_swarm}. Throughout the evolution, the language has had a number of functions developed, which nowadays tend to be presented as the key features distinguishing Python from other languages ~\cite{py_about}:
\begin{itemize}
\item{Very clear, readable syntax}
\item{Intuitive object orientation}
\item{Full modularity, supporting hierarchical packages}
\item{Very high level dynamic data types}
\item{Extensive standard libraries and third party modules for virtually every task}
\item{Extensions and modules easily written in C, C++ (or Java for Jython, or .NET languages for IronPython)}
\end{itemize}
Beside the above, it is important to note that Python belongs to a group of interpreted languages, which means that the code might be transformed to a hardware-independent byte-code and then used by the interpreter to call machine statements. To compare the latter with the classic cases, typically compiled language code is transformed to hardware-dependent machine commands and loses flexibility, having to combine with every platform the language is supposed to run on after the tiniest source code modification. This is easily avoidable in the case of Python as the cross-platform code is flexible enough to debug and maintain. Moreover, it should not escape attention that Python is written in C, using the language in a highly optimized way while running functions. Consequently, the code may stay both compressed and fast, which makes the source code files shorter and more user-friendly in terms of their readability. That is another reason, next to wide documentation on why "Python is friendly... and easy to learn"~\cite{py_about}. Finally, what is not negligible is the licensing issue. The fact that Python is distributed under an Open Source license makes the language freely usable and distributable not only for non-profit use, but also for commercial purposes without additional restrictions. The latter might have yet broader meaning as in the light of law, Python cannot become a closed and commercial product, which leaves developers relying on their creativity stemming from nothing else than the use of the code. This particular feature is one of the characteristics distinguishing Python from other languages and the below section will present other points of comparison.

\subsection{Comparison with other languages}\label{subsec:lang_compare}
*****It is a fairly hard task to objectively make any general comparisons on programming languages and as mentioned in \ref{sec:languages} languages can be compared to different tools that in hand of programmers can help to solve particular problems. As it is about experience and cooperation with already available tools it is impossible to point one language that would be optimum choice for solving all possible problems even regarding a single application. That is a reason why it is quite common that software projects used to be written by use of more languages. Nevertheless it is interesting to show the graphical illustration of community activity of particular languages. I have chosen C\#, C++, Java, Python and Ruby to focus on as the most popular object-oriented programing\footnote{Object Oriented Programming OOP is one of programing paradigms that operates on data structures called objects. With such operations like inheritance, data abstraction or encapsulation it allows for effective attempting complicated problems in a human friendly way.} languages. The graphs below difference the activity of regarding  this languages in two perspectives by number of projects on the left and number of active contributors on the right.
\begin{figure}[ht]
  \begin{center}
    \subfigure[\textbf{Monthly Projects}.~\cite{ohloh_projects} \newline The lines show the count of projects with at least \newline one line of code changed in a month.]{\label{ohloh_projects}\includegraphics[scale=0.36]{img/Monthly_projects.png}}
    \subfigure[\textbf{Monthly Contributors}.~\cite{ohloh_contributors} \newline The lines show the number of developers who have contributed at least one line of code in each month]{\label{ohloh_contributors}\includegraphics[scale=0.36]{img/Monthly_contributors.png}}
  \end{center}
  \caption{Programming languages activity graphs.}
  \label{ohloh_lang_graph}
\end{figure}
One of conclusions from the graphs above is that Python community remains very active and for long years  keeps it position in the group of top active ones. Despite the passing years Python language keeps paste with he the changes happening in the software world and is very interesting option that has proofed its usability in miscellaneous areas.  

\section{Scalability}\label{sec:scalability}
To define the scalability term I will base on work done by Cal Henderson in his book~\cite[pages 203--204]{build_scalable} where he points thee characteristics that scalable system should have:
\begin{itemize}
\item{The system can accommodate increased usage.}
\item{The system can accommodate increased dataset.}
\item{The system is maintainable.}
\end{itemize}
That definition does not require much additional explanations. However it is a basic criteria that should help to understand the term meaning but does not exploit the problematics standing behind it. It may be crucial to understand that scalability as a process of planning should be grounded before the increase will happen. In plain words scalability pattern could stand for 'increase ready' what in the real-world project has some certain consequences:
\begin{itemize}
\item{Capital investment will be made.}
\item{The system will become more complex.}
\item{Maintenance costs will increase.}
\item{Time will be required to act.}
\end{itemize}
Accordingly to the author of  "Scalable Internet Architectures"~\cite[page 8]{scalable_arch} above four points are guaranteed when scaling any system. Therefore scalability has it own cost that should make the desired growth on scale more profitable if not only possible. As horizontal scaling means expenses for extra number of elements that brand or model that is already in use. Vertical scaling would aim in replacing existing components with newer more powerful. Both according to their concept assume minimum required work on architecture however horizontal scaling is the best and only true~\cite[page 5]{scalable_arch} type of scalability. Vertical scaling has two huge disadvantages when related to horizontal scaling model. First one are limitations above which system that uses vertical scaling can not scale more. Its due the hardware limitations as the system components can be exchanged to more powerful up to some certain limit dictated by the current technology level. Second one is the cost efficiency as the vertical scaling cost model doesn't scale linearly~\cite[page 204]{build_scalable}. Investing more on medium class components seams to be more flexible and financial effective way to make the system scale wide. On the other hand it is remarkable that the system will become more complexed as adding numerous components increases the risk of failure of single element of system. This consideration should also take into account that horizontal scaling concept utilizes already known and well proofed components wheres vertical scaling requires from system engineers some additional work to learn and check just installed elements.

Concluding above considerations it is clear that scalable applications have their cost which allows their developers fill confident in case the system will get on popularity. By choosing horizontal scaling model it will be possible to have the system and the expanses under control. That makes the system reliable also to its users who can use the system with guaranteed level of quality.         
 
\section{Google App Engine platform}\label{sec:gae_general}
Google App Engine GAE is one of the Google products that provides web applications hosting, data storage and great performance networking by using rock-solid Google infrastructure~\cite[page 1]{gae_develop}. It was primary supporting only Python runtime but starting from April 2009 it is also available for Java runtime. This product is continuously developed by the Google team and newer versions of Software Development Kit SDK becomes regularly released. GAE is a very interesting initiative from Google to let the developers use Google's own infrastructure like GFS\footnote{GFS is an acronym for Google File System. It is an internal technology of Google that allowed to build distributed, vault tolerant jet hight availability system for various of Google services.} or BigTable\footnote{BigTable is Google concept for Data Store. It is a kind of hash table database with many advanced features like entity groups or transactions. As claimed in the official BigTable paper~\cite{bigtable_about} many of Google projects including Google Earth and Google Finance use BigTable entities to store its data.}. The idea behind GAE was to let the developer concentrate on developing application letting Google team care for the infrastructure and that accordingly to GAE homepage~\cite{gae_homepage} done in a easy way.Google points~\cite{gae_why} a few reasons for why App Engine may be right the right choice: 
\begin{itemize}
\item{Easy to get Started. Users of GAE won't have to worry about system administration, tweak the configuration, buy extra machines of search for another static content server.}
\item{Automatic scalability. By organizing the code to fit the GAE design the application will become well structured and easier to scale when running on Google infrastructure.} 
\item{The reliability, performance and security of Google's infrastructure. Taking advantage of the 10 years of experience in building performance driven and secure systems the same rules apply to applications hosted on GAE.}
\item{Cost efficient hosting. When running on GAE there machine resources are not that a issue -- if the application can fit the free quota thats fine in case it needs more power Google offers really competitive pricing.}
\item{Risk free trial period. After creating an account and publishing an application people can straight away start to use it with quite generous limit of 5 million page views a month. Thats is free without any obligations.}
\end{itemize}
Apart from the Google massive infrastructure GAE can not be truly compared to any of the LAMP\footnote{Primary and most popular acronym is LAMP and it stands for Linux, Apache, Mysql, and PHP that on other operating systems this became WAMP for Microsoft Windows and MAMP in case of Apple's Mac OS X. This is the basic infrastructure needed to run a web based applications.} packages. It extends that idea for a local development environment end 'production' environment where the application runs after deployment. With the SDK provided by Google for the Mac OS X developers can make use of GoogleAppEngineLauncher which eases the development process. The application can be uploaded to Google with one press of the button. This application is presented on figure \ref{gae_launcher}.
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.4]{img/gae_launcher.png}
\caption{Goole App Engine launcher application.}
\label{gae_launcher}
\end{center}
\end{figure}

Some of other features that are highly useful in the application development life-cycle or just extend the basic GAE functionality for even better performance and flexibility are:
\begin{itemize}
\item{Application dashboard.This is the developer best help where he can navigate to other tools, have the application status overview with such a figures like used resources, recent load, recent errors generated by the application and some charts showing number of request per second, milliseconds per request and many other figures.}
\item{System status. This service shows the GAE system status itself. Google has massive resources therefore makes use of redundancy however for various reasons it is reasonable to have the GAE system monitoring as well. It shows when some important maintenance jobs are planed and few more informations like components statuses and write, read latency. This service is also available as alert RSS feed to stay updated with recent changes without the need to continuously follow the web page.}
\item{Memcashed. This technology was invented by the developers of Danga Interactive a company that became acquired by Six Apart company. Is creators got realized that they can achieve a huge gain on performance by storing the functions output in memory and in case of subsequent calls to that functions returning stored value. This makes use of that the retuned values are invariant otherwise the stored (cashed) values are removed form Memcashed and replaced with the new value. Other great advantage of that technology is that it can be transparently distributed between numerous machines.} 
\item{Interactive console.This facility allows for interacting with the application both during development and after deployment. By use of it developers may run some control tasks, interact with the Datastore or perform some higher level debugging.}
\item{Datastore data browser. Here the storage engine can be browsed in a user friendly way. Data is clearly organized allowing to perform basic CRUD\footnote{CRUD is an acronym for Create Read Update and Delete. This is a group of basic operations that are most frequent performed on data sets.} operations.}
\item{Cron jobs.} Cron is accualy not invention of Google. It is much older idea that came from UNIX wold. It role is to run user defined task synchronously. Also the GAE cron tasks are nothing more than that -- a configuration file which seas what and when should be done. An example of it usage could be for instance sending weekly report to registered users summing up the market behavior in case of business analytics application.     
\item{Task queues.} This feature extends the cron jobs functionality.It allows to the developer to create a queue with some parameters like number of tasks to run per second and append tasks to that queue. Its an efficient way to run asynchronously some jobs in the background when the system load is not lower.  
\end{itemize}

Finally GAE can be proud of it developers community build by GAE users and the Google developers working on GAE itself. Thanks them GAE has a detailed and clear documentation with practical examples. Users of IRC\footnote{IRC stands for Internet Relay Chat and by use of that protocol users can perform online conversations in a wide audience or witch chosen persons.} can get answer to their questions by visiting \#appengine channel on the freenode network. Besides Google cares for good GAE promotion by presenting applications developed with the help of it. This way a very rich library of resources is available for beginners just as for advanced users who wont to try something new. 
  
  
\subsection{The Python Runtime}\label{sec:gae_py}
After installing Google App Engine SDK the empty project contains of three files:
\begin{itemize}
\item{app.yaml}
\item{index.yaml}
\item{main.py}
\end{itemize}
\subsection{The webapp framework}\label{sec:webapp}
\subsection{The Django framework}\label{sec:django}