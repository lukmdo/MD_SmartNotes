\chapter{Introduction}
\label{sec:Introduction}
Creating network applications nowadays might be a complicated process of design which involves long series of research and experiments or, on the other hand, it might be a fairly simple procedure that takes only a tenth of its time and effort. In both cases, a frequent evaluation metric is the scalability of the application, more than a thousand of lines of code or the complexity of the model. With the rise in popularity, the usage of network applications increases, which in consequence results in an increase in frequency that the application is requested to serve its functionality. This growth can be calculated and included at the planing level, thus becoming a good programming practice that places itself close to other widely approved design patterns. With no doubt is scalability starting to play a more important role, being often set at the same level with such issues like portability or security[quote]. The present thesis aims to introduce an application that by its original functionality would heave the potential to become a heavy traffic network application with numerous active users.

\section{Popular notes taking applications}\label{sec:popular_apps} 
blablabla
\subsection{Appx}\label{subsec:x} 
\subsection{Appy}
\subsection{Comparison}
\section{Popular Version Control Systems}\label{sec:popular_vcs}
Imagine a group of developers working together on some pice of software.  Most probably they divided they work into functional pieces and made necessary planing. Then they start to code accordingly to the company's coding standards, used methodology or favorite schema. Doubtless they will need to interact not only by exchanging ideas but also by working on same parts of code simultaneously.  At that point they want to work uninterrupted on their code by the same time letting other people to view their work progress or allow to make any modifications that they might want to. That basic need was the primary reason for inventing external software which additionally could tell the to the developer what has changed since the last time he worked on the code or merge the the work of several developers. 

Although currently there exists a wide variety of VCS (Version Control Systems) offering diverse functionality the true golden age for VCS was started relatively not long ago. It was 2001 when after great success of CVS (Concurrent Version Control) Jim Blandy and Karl Fogel, started a new project aiming to replace CVS by solving already well known inconveniences of CVS, better architecture and cleaner code\cite{hg_book}. This project has been called Subversion also known as SVN by it's commandlne utility name. Although its CVS which probably holds a title of the world's most widely used VCS it is SVN which birth effected in dozens of new and original concepts. Some of this started some time after SVN like Mercurial, Bazzar, Darts other like Git or Guilt needed time to evolute and gain new developers to join the group of wold famous VCS systems. Nevertheless the first VCS are much older and one of the very first ones called SCCS (Source Code Control System) was grounded in 1970s at Bell Labs. When taken into account that at that time computer popularity was not that strong and access to computers was much more the dynamics in which the VCS systems were developed during those days wont seam strange. 
\subsection{Mercurial}\label{subsec:hg}
Mercurial is a DVCS (Distributed Version Control System) which is one of VCS models. Describing DVCS in general makes it easier to understand how Mercurial system might be used and to which use cases it suits well. In comparison to SVN or any other centralized VCS where only one main machine contains the repository with its history DVCS make every user to have the those on his hard disk. That in consequence makes each have the write access to the repository with all the available tools. Moreover it allows the user work undisturbed disregarding the server status as he servers the role of server for himself. This simple modification to the concept of centralized VCS was exactly that what dynamically expanding Open Source projects were seeking. Each developer might work on his repository allowing others to use his work by performing merge operation and using work of others just in the same order. No longer network connection to main server was needed in order to have a functional environment. Developers could analyze, create, modify code whenever they wonted to. That was not only a step forward in making VCS more user friendly but also improved the performance of this systems. All metadata concerning repository was placed on users hard disks. There was no reason to connect to the main sever to for example find the date when somebody made the modifications of a class that unexpected stopped to work correctly. This also made this systems more scalable as for the DVCS the central machine, if present, is only used as public main stream version of a project consuming minimum of the machine CPU and disk space. It only role is to allow users to download the most recent version of repository. By having the project with it history saved on every developer hard disk problem of backups was automatically solved and made it perfectly crush secure. On the other hand it might seem that maintaining repository with their history makes the cumulative size of repository much larger. Metadata with the development history is naturally some additional overhead that has to be stored on users disks but typically it does not overlap the three size of the metadata free repository. That is the price that the DVCS users have to agree to pay for the additional functionality which the  system offers. It is also worth to note that this systems by design were encouraging its users to experimenting. Some operations like branching or forking were created just for that purpose. Making frequent tries beyond the main version was a desirable feature in order to keep the history clean on the one hand  and allowing developers to perform as may tries as they might wont to on the other. In that way this systems played important role for  Open Source communities by helping to build and keep the community healthy \cite{git_talk,svn_talk}. Despite of that aspects DVCS has a bunch of advantages also for commercial projects. Bryan O'Sullivan points in \cite{hg_book} few of them: 
\begin{itemize}
\item{Better availability and reliability for teams that are scattered across the globe.}
\item{Better scalability and easier to maintain.}
\item{Greater flexibility what might be a value for target customer.}
\end{itemize}
What also counts Mercurial is easier to learn and uses similar commands which SVN or CSV were using what eases the transition. Next advantage of Mercurial that is frequently outlined is the very good Microsoft Windows operating system support just like for the other platforms like Linux or Apple OS X. Finally Marcurial has a very efficient HTTP protocol support \cite{google_hg_git_compare} both as client and server application. This feature counts much if the work on particular repository is tend to be very active in a group of the developers.

\subsection{Mercurial comparison with other systems}\label{subsec:dvcs_compare}
There exist lots of other interesting distributed version control systems which offer interesting functionality. Some of them like atomic commits, GUI\footnote{Graphical User Interface -- it eases the usage of system to users which are not used to work with command line tools.} tools, commits tagging, tracking merge operations in the history or allowing for user defined actions just before or after certain actions performed on repository are only few of which are commonly used for DVCS comparisons\cite{wiki_dvcs_compare}. With time the already long list\cite{wiki_dvcs_list} will probably continue to expand. Nevertheless currently Mercurial most popular alternatives are Git and Bazzar. Git comes from Linux kernel developers community and Bazzar is close with GNU\footnote{The name “GNU” is a recursive acronym for “GNU's Not Unix!”. The GNU Project was launched in 1984 to develop a complete Unix-like operating system which is free software and currently is recognizable for GNU/Linux operating system.} developers group. Both are great systems using some slightly different concepts. Both use C language what should have an positive effect on their performance. However it needs compilation and might not be suitable to systems which don't allow for running binary programs. The biggest difference is the level of complexity. On one hand Git provides numerous commands and arguments allowing for full control over repository and it history and on the other Bazzar which motto says "Bazaar adapts to the way you want to work". In that subject Bazzar stays close to Mercurial which allows to use the version control system spending minimum time on learning the proper usage. In the maintenance of a repository Mercurial is absolutely number one. It does not require any additional operations like running \texttt{git-gc}\footnote{bla bla bla} in case of Git and typically uses less disk space than Bazzar needs for the same repository. Apparently all tree systems reached a mature level what can the conclusion after using advanced commands, user interface tools availability and  advanced features as a comparison criteria. The most important reason for making a selection between many of VCS for a developer is frequently offered functionality and the habit of the group where he used to work. That was not the criteria that I followed by choosing a VCS for my application. I needed a lightweight yet powerful python based system with good support for running over HTTP requests. That filter was strict enough to choose Mercurial over other available systems.     

\section{Role of programming languge}\label{sec:language}
\subsection{Python}\label{subsec:py}
\subsection{Comparison with other languages}\label{subsec:lang_compare}
\section{Scalability}\label{sec:scalability}
\section{Google App Engine platform}\label{sec:gae_general}